import commandsimport osimport refrom utils.FileHandler import TextHandlerclass Init:    def __init__(self):        # print "check if it is the first init"  # init once for importing        self.shell_rc = ""        self.handler = None        self.mongos = []        self.alias_pattern = "alias mongo_(.+)="        self.backup()    def backup(self):        user_home = commands.getoutput("eval echo ~$USER")        shell_path = commands.getoutput("echo $SHELL")  # '$0' in python shell echos 'sh'        shell = shell_path.split("/")[-1]  # /bin/zsh or /bin/bash        def _gen_path(suffix):            return "{}/.{}{}".format(user_home, shell, suffix)        shell_profile = _gen_path("_profile")        self.shell_rc = _gen_path("rc")        shell_rc_backup = _gen_path("rc.bak")        # create _profile to active rc for every new terminal        if not os.path.isfile(shell_profile):            with open(shell_profile, "w") as f:                f.write("source {}".format(self.shell_rc))            print "create: {}".format(shell_profile)        # create a backup if it doesn't exist        if not os.path.isfile(shell_rc_backup):            with open(self.shell_rc, "r") as origin:                with open(shell_rc_backup, "w") as back_up:                    back_up.write(origin.read())            print "create: {}".format(shell_rc_backup)        self.handler = TextHandler(self.shell_rc)        self.mongos = self.handler.find(self.alias_pattern)        return self.shell_rc    def get_value_form_option(self, sys_args, option):        if option not in sys_args:            # raise ValueError("option {} is needed".format(option))            self.exception("option '{}' is needed".format(option))        try:            value = sys_args[sys_args.index(option) + 1]            if not value.startswith("-"):                return value            raise IndexError        except IndexError as e:            # raise ValueError("value of option {} is needed".format(option))            self.exception("value of option '{}' is needed".format(option))    def generate_alias_string(self, name, host):        return 'alias mongo_{}="{}"'.format(name, self.get_mongo_command(host))    def get_mongo_command(self, cmd):        mongo_command = 'mongo {}'.format(cmd) if not cmd.startswith("mongo") else cmd        ok, msg = self.connection_test(mongo_command)        if ok:            return mongo_command        # messages that can be solved by user, more arguments needed  # FIXME Unauthorized required input twice        msg_map = {            "Unauthorized": self.username_and_password_needed,            "Authentication failed": self.auth_database_not_admin,            "Server is not running": self.start_mongod_local        }        if not msg_map.get(msg):            self.exception(msg)        mongo_command = msg_map[msg](mongo_command)        return self.get_mongo_command(mongo_command) if mongo_command else ""    def find_alias_string(self, index_or_name):        name = self.get_name_or_by_index(index_or_name)        return re.findall('alias mongo_' + name + '=.*', self.handler.content)    def get_name_or_by_index(self, index_or_name):        try:            index = int(index_or_name)            if index + 1 > len(self.mongos):                self.exception("mongo name with number '{}' does not exist".format(index))            name = self.mongos[index]        except ValueError:            name = index_or_name            if index_or_name not in self.mongos:                self.exception("mongo name '{}' does not exist".format(name))        return name    @staticmethod    def exception(msg):        try:            raise IOError        except IOError:            print "Error: {}".format(msg)            exit(1)    @staticmethod    def auth_database_not_admin(command):        auth_database = raw_input("authenticationDatabase: ")        command.replace("--authenticationDatabase admin", "--authenticationDatabase {}".format(auth_database))        return command    @staticmethod    def username_and_password_needed(command):        # FIXME problem may occurs,        #  when the existing complete command,        #  with username and password,        #  comes with 'Unauthorized' error        username = raw_input("username: ")        password = raw_input("password: ")        return "{} -u {} -p {} --authenticationDatabase admin".format(command, username, password)    #    # @staticmethod    # def start_mongo_service(command):    #     print command    #     username = raw_input("would you like to run this mongo service: ")    #     password = raw_input("password: ")    #     return "{} -u {} -p {} --authenticationDatabase admin".format(command, username, password)    @staticmethod    def connection_test(mongo_command):        # FIXME can only test complete command instead of alias        status, outputs = commands.getstatusoutput("echo 'show dbs' | {}".format(mongo_command))        if status == 0:            return True, "success"        code_names = re.findall('"codeName" : "(.+)"', outputs)        if code_names and code_names[0] == "Unauthorized":            return False, "Unauthorized"        code_names = re.findall('Error: (.+)', outputs)        # TODO Error types should be const too        if code_names and code_names[0].startswith("Authentication failed"):            return False, "Authentication failed"        if code_names and code_names[0].startswith("couldn't connect to server"):            return False, "Server is not running"        return False, outputs    @property    def local_ip_address(self):        import socket        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)        s.connect(("8.8.8.8", 80))        return s.getsockname()[0]    def new_guake(self, command):        commands.getoutput('guake -n NEW -e "{}"'.format(command))    def add_mongod_local(self):        command = raw_input("\nplease enter the effective mongod command: ")        # status, output = commands.getstatusoutput(command)        # if status != 0:        #     self.exception(output)        self.handler.append('alias mongod_local="{}"'.format(command))        self.new_guake(command)        exit(0)    def run_mongod_local(self, ip_addresses):        mongod_local = self.handler.find('^alias mongod_local=.*')        if mongod_local:            self.new_guake("mongod_local &")            return True        for ip in ip_addresses:            command = self.handler.find('^alias.*"(.*mongod .*--bind_ip ' + ip + '.*)"')            if command:                self.new_guake(command[0] + "&")                return True        return False    def start_mongod_local(self, mongo_command):        print "\nWarning: mongod service is not running"        if mongo_command.split()[1] not in ["127.0.0.1", self.local_ip_address]:            self.exception("failed to connect remote mongo service")        conform = raw_input("would you like to run the local service? (Y/N)")        if conform in ["y", "Y", ""]:            if not self.run_mongod_local(["127.0.0.1", self.local_ip_address]):                print "\nWarning: alias 'mongod_local' not found"                conform = raw_input("would you like to add a mongod alias? (Y/N)")                if conform in ["y", "Y", ""]:                    self.add_mongod_local()            # new guake is running            exit(0)        return ""